; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=hs32 -verify-machineinstrs < %s \
; RUN:   | FileCheck %s -check-prefix=HS32

define i32 @loadw(i32 *%a) nounwind {
; HS32-LABEL: loadw:
; HS32:       ; %bb.0:
; HS32-NEXT:    mov r0, 8
; HS32-NEXT:    movt r0, 4
; HS32-NEXT:    add r0, r1, r0
; HS32-NEXT:    ldr r0, [r0]
; HS32-NEXT:    ldr r0, [r1]
; HS32-NEXT:    ldr r10, [r1-12]
; HS32-NEXT:    mov pc, lr
  %1 = getelementptr i32, i32 *%a, i32 -3
  %2 = getelementptr i32, i32 *%a, i32 65538
  %3 = load i32, i32* %1                      ; test load indexed address
  %4 = load volatile i32, i32* %2             ; test load indexed > 16 bits
  %5 = load volatile i32, i32* %a             ; test load non-indexed address
  ret i32 %3
}

define void @storew(i32 *%a, i32 %b) nounwind {
; HS32-LABEL: storew:
; HS32:       ; %bb.0:
; HS32-NEXT:    str [r1-4], r2
; HS32-NEXT:    mov r0, 8
; HS32-NEXT:    movt r0, 4
; HS32-NEXT:    add r0, r1, r0
; HS32-NEXT:    str [r0], r2
; HS32-NEXT:    str [r1], r2
; HS32-NEXT:    mov pc, lr
  %1 = getelementptr i32, i32 *%a, i32 -1
  %2 = getelementptr i32, i32 *%a, i32 65538
  store volatile i32 %b, i32* %1            ; test load indexed address
  store volatile i32 %b, i32* %2            ; test load indexed > 16 bits
  store volatile i32 %b, i32* %a            ; test load non-indexed address
  ret void
}

@G = global i32 0

define i32 @lw_sw_global(i32 %a) nounwind {
; HS32-LABEL: lw_sw_global:
; HS32:       ; %bb.0:
; HS32-NEXT:    mov r0, %lo(G)
; HS32-NEXT:    movt r0, %hi(G)
; HS32-NEXT:    ldr r10, [r0]
; HS32-NEXT:    str [r0], r1
; HS32-NEXT:    ldr r11, [r0+100]
; HS32-NEXT:    str [r0+100], r1
; HS32-NEXT:    mov pc, lr
  %1 = load volatile i32, i32* @G
  store i32 %a, i32* @G
  %2 = getelementptr i32, i32* @G, i32 25
  %3 = load volatile i32, i32* %2
  store i32 %a, i32* %2
  ret i32 %1
}
